---
name: What-If 分析改进建议
overview: 从场景与基线管理、多变量/敏感性分析、执行一致性、安全与可观测性等维度，列出当前工程的不足并给出可落地的改进方向与优先级。
todos: []
isProject: false
---

# 更完善的 What-If 分析：工程改进建议

## 一、当前不足概览


| 维度     | 现状                                                      | 影响                         |
| ------ | ------------------------------------------------------- | -------------------------- |
| 场景与基线  | 无快照/恢复，What-If 直接改 executor 内存                          | 连续多次 what-if 会叠加，无法与“基线”对比 |
| 多变量    | 仅单属性单次修改                                                | 无法表达“同时改价格+数量”等组合场景        |
| 敏感性分析  | 无                                                       | 无法做“价格从 80 到 120 步进”的扫描    |
| 执行双路径  | WhatIf 只绑 ComputationGraphExecutor；Neo4j 路径无 what-if 封装 | 行为不一致，Neo4j 写回易覆盖真实数据      |
| 写回策略   | 传了 output_node_id 就写回 Neo4j                             | 容易误把 what-if 结果当真实数据持久化    |
| 影响分析   | 无                                                       | 无法回答“改 X 会影响哪些节点/输出”       |
| 执行安全   | 用 `eval(code, {}, variables)` 执行表达式                     | 存在注入与安全风险；注释已提示生产需更安全方式    |
| 错误与可观测 | 大量 print、单节点失败仅打印继续跑                                    | 难以程序化使用、难以区分“基线 vs 场景”结果   |


---

## 二、改进建议（按优先级）

### 1. 场景与基线管理（高）

**问题**：[WhatIfSimulator](src/domain/services/what_if_simulator.py) 在 `simulate_*` 里直接 `update_node_property`，不保存基线、不恢复。连续调用例如先 `simulate_price_change` 再 `simulate_quantity_change` 时，第二次是在“已改价”的基础上改数量，无法做“基线 vs 仅改价 vs 仅改量”的并列对比。

**建议**：

- **基线快照与恢复**：在 `ComputationGraphExecutor` 或 Simulator 层增加：
  - `snapshot_baseline()`：深拷贝当前所有数据节点状态（或仅“可驱动计算的”输入+输出）。
  - `restore_baseline()`：用快照恢复 executor 状态。
- **命名场景**：引入轻量“场景”概念：
  - `run_scenario(name, overrides) -> ScenarioResult`：在基线之上应用 `overrides`（如 `{node_id: {prop: value}}`），执行后返回结构化结果（见下），**不**写回 Neo4j，且执行前从基线恢复，保证每次都在同一基线跑。
- 这样：基线保留一份，多次 what-if 各自在基线上改不同 overrides，结果可对比。

**涉及文件**：[what_if_simulator.py](src/domain/services/what_if_simulator.py)、[computation_graph_executor.py](src/domain/services/computation_graph_executor.py)（若在 executor 层做快照/恢复）。

---

### 2. 多变量 What-If 与结构化结果（高）

**问题**：目前只有单属性修改（`simulate_property_change(node_id, property_name, new_value)`），无法一次描述“多节点多属性”的假设。

**建议**：

- **批量 overrides**：  
`simulate_overrides(node_overrides: Dict[str, Dict[str, Any]], write_back: bool = False) -> ScenarioResult`  
其中 `node_overrides` 形如 `{node_id: {"price": 150, "quantity": 10}}`，在基线或当前状态上应用后重算，返回结构化结果。
- **结构化 ScenarioResult**：  
返回对象包含至少：`baseline_snapshot`（或 baseline_id）、`overrides`、`outputs_per_node`（各数据节点在本次场景下的关键输出）、`affected_node_ids`（可选，见下）。便于做“基线 vs 场景 A vs 场景 B”的表格或图表，且减少对 print 的依赖。

**涉及文件**：[what_if_simulator.py](src/domain/services/what_if_simulator.py)。

---

### 3. 写回策略与 Neo4j 一致性（高）

**问题**：  

- 传了 `output_node_id` 就会把当前（可能已是 what-if 结果）写回 Neo4j，容易把“假设”写成“真实”。  
- [Neo4jGraphManager.write_output_properties](src/domain/services/neo4j_graph_manager.py) 直接覆盖节点属性，没有“仅写回真实执行”与“仅写回 what-if 分支”的区分。

**建议**：

- **显式写回开关**：所有 `simulate_*` 统一为 `write_back: bool = False`（或保留 `output_node_id: Optional[str] = None` 但文档明确“仅在实际确认落库时传”），默认不写回。
- **可选“场景节点”**：若需持久化 what-if 结果，可写回到一个“场景节点”或单独属性（如 `scenario_xyz_final_price`），而不是覆盖主数据节点的同一属性；由调用方或配置决定。
- **Neo4j 路径的 What-If**：使用 ComputationExecutor（Neo4j）时，what-if 应在“从 Neo4j 拉取 → 内存中改 overrides → 在内存/临时图上执行”的路径上做，结果不直接写回主图，或通过上述“场景节点”写回，避免与真实数据混淆。

---

### 4. 敏感性分析（中）

**问题**：没有“单变量在一个区间内步进、观察输出变化”的能力。

**建议**：

- **单变量扫描 API**：  
`sensitivity_scan(node_id, property_name, value_range: Sequence, step_or_points=...) -> List[ScenarioResult]`  
在基线上固定其他输入，仅对该属性在 `value_range` 上取点，每次跑一次场景，返回结果列表；可再封装为 `(input_value, output_value)` 的表格或曲线数据，便于前端/报表绘图。
- 实现可基于现有的 `run_scenario`/`simulate_overrides`，避免重复执行逻辑。

**涉及文件**：新增（如 `sensitivity.py` 或放在 [what_if_simulator.py](src/domain/services/what_if_simulator.py) 中）。

---

### 5. 影响分析（中）

**问题**：无法程序化回答“若修改节点 N 的某属性，会影响哪些计算节点和哪些输出属性”。

**建议**：

- 利用 [ComputationGraph.get_dependents](src/domain/models/computation_graph.py) 与依赖图（注意当前 `get_dependents` 基于 `output_to`，若依赖图是“数据节点→计算节点”的 DEPENDS_ON，可能需要从“数据节点/属性”反查依赖该属性的计算节点，再沿 OUTPUT_TO 找下游）。
- **API**：`get_impact_for_input(data_node_id, property_name) -> List[ComputationNode]` 或 `-> Set[output_property_names]`，返回会受该输入影响的计算节点或最终输出属性，便于解释和 UI（如高亮受影响节点）。

**涉及文件**：[computation_graph.py](src/domain/models/computation_graph.py) 或 domain/services 下新模块（如 `impact.py`）。

---

### 6. 执行安全与输入校验（中）

**问题**：  

- [computation_graph_executor.py 第 92 行](src/domain/services/computation_graph_executor.py)、[computation_executor.py 第 479 行](src/domain/services/computation_executor.py) 使用 `eval(node.code, {}, variables)`，存在代码注入风险；注释已注明“生产环境应用更安全方式”。  
- 对输入无类型/范围校验，异常值会导致难以理解的错误或错误传播。

**建议**：

- **安全执行**：用受限执行替代裸 `eval`，例如：  
  - 仅允许数学/比较表达式的 AST 白名单（如 `ast.parse` + 只允许 `Expression`、`BinOp`、`Compare`、`Call` 限定函数如 `min/max` 等）；或  
  - 使用已有安全表达式库（如 `simpleeval`、`asteval` 等）并限制可用名字空间。
- **输入校验（可选）**：在 InputSpec 或 ComputationNode 上支持可选的 `constraints`（类型、min/max），在执行前校验 `variables`，失败时明确报错而不进入 eval。

**涉及文件**：[computation_graph_executor.py](src/domain/services/computation_graph_executor.py)、[computation_executor.py](src/domain/services/computation_executor.py)、可选 [io_spec.py](src/domain/models/io_spec.py) 或 computation_node。

---

### 7. 错误处理与部分执行（中低）

**问题**：[computation_graph_executor._execute_node](src/domain/services/computation_graph_executor.py) 中若 `eval` 抛错，仅 `print` 后 `return None`，后继节点仍会执行并可能使用到未更新或错误的上游结果，导致“静默错误传播”。

**建议**：

- 区分“可恢复/不可恢复”：例如对单节点失败，可记录到本次执行结果（如 `ScenarioResult.errors: List[NodeError]`），并选择策略：  
  - **fail_fast**：任一步失败即中止并返回已执行部分 + 错误；  
  - **best_effort**：继续执行但标记依赖该节点的下游为“脏/不可用”。
- 返回结构化结果时带上 `success: bool` 与 `errors`，便于上层决定是否写回或展示。

**涉及文件**：[computation_graph_executor.py](src/domain/services/computation_graph_executor.py)。

---

### 8. 可观测性与 API 化（低）

**问题**：Simulator 内大量 `print`，不利于嵌入到服务/前端或做自动化测试；结果依赖“看控制台”而非结构化数据。

**建议**：

- 所有 `simulate_*` / `run_scenario` 统一返回结构化对象（如 `ScenarioResult`），包含 overrides、outputs、errors、affected_nodes（可选）。
- 将“打印”改为可选：例如 `verbose: bool = False` 或通过 `logger` 输出，默认不打印；若需要，可由调用方根据 `ScenarioResult` 自行格式化输出或写日志。

**涉及文件**：[what_if_simulator.py](src/domain/services/what_if_simulator.py)。

---

### 9. 执行双路径统一（低）

**问题**：What-If 仅基于 ComputationGraphExecutor（内存 + NetworkX）；ComputationExecutor（Neo4j 全流程）没有对等的 what-if 封装，且两种路径语义需保持一致。

**建议**：

- 明确“推荐 what-if 路径”：从 Neo4j 拉取数据 → 用 ComputationGraphExecutor + 内存 node_data_map 做 what-if（含基线/多场景/敏感性）→ 仅当用户确认时再写回。  
- 或为 ComputationExecutor 提供“只读 what-if”模式：克隆/临时图 + 内存 overrides，执行后返回结果不写回，与当前 Simulator 行为对齐。  
- 文档中说明两条路径的职责与推荐用法，避免“Neo4j 路径下误把 what-if 写回主图”。

---

## 三、实施顺序建议

1. **先做 1 + 2 + 3**：基线/快照与恢复、多变量 overrides + ScenarioResult、写回默认关闭并显式化。这样即可支持“多场景并列对比”且不误写库。
2. **再做 4 和 5**：敏感性扫描与影响分析，提升分析能力与可解释性。
3. **随后 6 和 7**：安全执行与错误策略，提升健壮性。
4. **最后 8 和 9**：可观测性与双路径统一，便于集成与维护。

---

## 四、小结

要做出更完善的 what-if 分析，工程上最关键的改进是：**可恢复的基线 + 命名/多变量场景 + 结构化结果 + 写回可控**；在此基础上再补上敏感性、影响分析、安全执行与错误处理，即可在不大改架构的前提下显著提升分析的完整性与可用性。